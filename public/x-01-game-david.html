<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Smoother Jumping Platformer</title>
<style>
  body {
    margin: 0;
    background: #222;
    color: #eee;
    font-family: monospace, monospace;
    overflow: hidden;
    user-select: none;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #333;
    border: 2px solid #555;
  }
  #score {
    text-align: center;
    font-size: 20px;
    margin-top: 6px;
  }
</style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>
<div id="score">Score: 0</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Player constants
  const PLAYER_WIDTH = 30;
  const PLAYER_HEIGHT = 50;
  const PLAYER_X = 100;

  // Physics constants (tweaked)
  const GRAVITY = 0.5; // less gravity for smoother jump
  const JUMP_VELOCITY = -12; // a bit less jump power for better control
  const MAX_FALL_SPEED = 20; // cap falling speed
  const PLATFORM_SPEED = 3;

  let score = 0;
  let gameOver = false;

  // Player state
  const player = {
    x: PLAYER_X,
    y: HEIGHT - PLAYER_HEIGHT - 20, // start standing on initial platform
    width: PLAYER_WIDTH,
    height: PLAYER_HEIGHT,
    vy: 0,
    onPlatform: false,
  };

  // Platforms array
  let platforms = [];

  // Initial ground platform
  platforms.push({
    x: 0,
    y: HEIGHT - 20,
    width: WIDTH,
    height: 20,
  });

  // Platform spawn config (closer and smoother height changes)
  const PLATFORM_MIN_WIDTH = 120;
  const PLATFORM_MAX_WIDTH = 200;
  const PLATFORM_MIN_HEIGHT = 15;
  const PLATFORM_MAX_HEIGHT = 25;
  const PLATFORM_MIN_Y = HEIGHT - 120;  // restrict vertical range to make jumps reasonable
  const PLATFORM_MAX_Y = HEIGHT - 40;

  // Input handling
  function jump() {
    if (player.onPlatform && !gameOver) {
      player.vy = JUMP_VELOCITY;
      player.onPlatform = false;
    }
  }

  window.addEventListener('keydown', e => {
    if ((e.code === 'Space' || e.code === 'ArrowUp')) {
      e.preventDefault();
      jump();
    } else if (gameOver && e.code === 'Enter') {
      restart();
    }
  });

  window.addEventListener('mousedown', () => {
    jump();
  });

  // Game loop variables
  let lastTime = null;

  function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaMs = timestamp - lastTime;
    lastTime = timestamp;

    if (gameOver) {
      drawGameOver();
      return;
    }

    update(deltaMs / 16.666);
    draw();

    requestAnimationFrame(gameLoop);
  }

  function update(delta) {
    // Apply gravity and cap falling speed
    player.vy += GRAVITY * delta;
    if (player.vy > MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED;
    player.y += player.vy * delta;

    // Don't let player go above top
    if (player.y < 0) {
      player.y = 0;
      player.vy = 0;
    }

    // Move platforms left
    for (const p of platforms) {
      p.x -= PLATFORM_SPEED * delta;
    }

    // Remove offscreen platforms
    while (platforms.length && platforms[0].x + platforms[0].width < 0) {
      platforms.shift();
    }

    // Spawn new platforms to keep scrolling
    let lastPlatform = platforms[platforms.length - 1];
    while (lastPlatform.x + lastPlatform.width < WIDTH + 250) {
      const width = randomRange(PLATFORM_MIN_WIDTH, PLATFORM_MAX_WIDTH);
      const height = randomRange(PLATFORM_MIN_HEIGHT, PLATFORM_MAX_HEIGHT);

      // Smooth Y difference for jumpable platforms
      // Clamp next platform Y within 40px up/down of last platform's Y
      let yMin = Math.max(PLATFORM_MIN_Y, lastPlatform.y - 40);
      let yMax = Math.min(PLATFORM_MAX_Y, lastPlatform.y + 40);
      let y = randomRange(yMin, yMax);

      lastPlatform = {
        x: lastPlatform.x + lastPlatform.width + randomRange(120, 170),
        y,
        width,
        height,
      };
      platforms.push(lastPlatform);
    }

    // Collision detection with platforms
    player.onPlatform = false;

    // We'll check a small vertical tolerance (5px) for landing to avoid sinking
    const tolerance = 5;

    for (const p of platforms) {
      const playerBottom = player.y + player.height;
      const platformTop = p.y;
      const platformBottom = p.y + p.height;

      if (
        player.x + player.width > p.x + 5 && // add small horizontal margins so player can land easier
        player.x < p.x + p.width - 5 &&
        playerBottom >= platformTop - tolerance &&
        playerBottom <= platformTop + tolerance &&
        player.vy >= 0
      ) {
        player.y = platformTop - player.height;
        player.vy = 0;
        player.onPlatform = true;
        break;
      }
    }

    // Check falling off screen
    if (player.y > HEIGHT) {
      gameOver = true;
    }

    // Score increment
    score += delta * 0.1;
    document.getElementById('score').textContent = 'Score: ' + Math.floor(score);
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Draw player
    ctx.fillStyle = '#2ecc71';
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // Draw platforms
    ctx.fillStyle = '#3498db';
    for (const p of platforms) {
      ctx.fillRect(p.x, p.y, p.width, p.height);
    }
  }

  function drawGameOver() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    ctx.fillStyle = '#e74c3c';
    ctx.font = 'bold 48px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 20);

    ctx.fillStyle = '#eee';
    ctx.font = '24px monospace';
    ctx.fillText('Score: ' + Math.floor(score), WIDTH / 2, HEIGHT / 2 + 20);
    ctx.fillText('Press Enter to Restart', WIDTH / 2, HEIGHT / 2 + 60);
  }

  function restart() {
    score = 0;
    gameOver = false;
    player.y = HEIGHT - PLAYER_HEIGHT - 20;
    player.vy = 0;
    player.onPlatform = false;
    platforms = [];
    platforms.push({
      x: 0,
      y: HEIGHT - 20,
      width: WIDTH,
      height: 20,
    });
    lastTime = null;
    document.getElementById('score').textContent = 'Score: 0';
    requestAnimationFrame(gameLoop);
  }

  function randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
