<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fixed Collision + Easier Jumps Platformer</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: monospace, monospace;
      overflow: hidden;
      user-select: none;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #333;
      border: 2px solid #555;
    }
    #score {
      text-align: center;
      font-size: 20px;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <canvas id="game" width="800" height="400"></canvas>
  <div id="score">Distance: 0</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Player constants
  const PLAYER_WIDTH = 30;
  const PLAYER_HEIGHT = 50;

  // Physics constants
  const GRAVITY = 0.6;
  const JUMP_VELOCITY = -12;
  const MAX_FALL_SPEED = 20;
  const PLAYER_SPEED = 4;

  // Camera config
  const CAMERA_RIGHT_EDGE = WIDTH * 0.6;
  const CAMERA_LEFT_EDGE = WIDTH * 0.3;

  let gameOver = false;
  let score = 0;

  // Input state
  const keys = {
    left: false,
    right: false,
    jump: false,
  };

  // Player state (world coordinates)
  const player = {
    x: 50, // start near left edge of world
    y: HEIGHT - 20 - PLAYER_HEIGHT,
    width: PLAYER_WIDTH,
    height: PLAYER_HEIGHT,
    vx: 0,
    vy: 0,
    onPlatform: false,
  };

  // Camera scroll offset (world coords of left screen edge)
  let cameraX = 0;

  // Platforms (world coords)
  let platforms = [];

  // Initial ground platform spanning the first 2000px
  platforms.push({
    x: 0,
    y: HEIGHT - 20,
    width: 2000,
    height: 20,
  });

  // Platform spawn config (tighter gaps and heights for easier jumps)
  const PLATFORM_MIN_WIDTH = 120;
  const PLATFORM_MAX_WIDTH = 180;
  const PLATFORM_MIN_HEIGHT = 15;
  const PLATFORM_MAX_HEIGHT = 25;
  const PLATFORM_MIN_Y = HEIGHT - 110;
  const PLATFORM_MAX_Y = HEIGHT - 50;
  const MAX_PLATFORM_GAP = 130; // max gap between platforms (reduced)
  const MAX_VERTICAL_DIFF = 35; // max vertical difference between consecutive platforms (reduced)

  // Handle keyboard input
  window.addEventListener('keydown', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
      e.preventDefault();
      keys.jump = true;
    }
    if (gameOver && e.code === 'Enter') {
      restart();
    }
  });

  window.addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = false;
  });

  // Mouse/touch jump
  window.addEventListener('mousedown', () => {
    keys.jump = true;
  });
  window.addEventListener('mouseup', () => {
    keys.jump = false;
  });

  // Spawn platforms ahead if needed
  function spawnPlatforms() {
    let lastPlatform = platforms[platforms.length - 1];
    while (lastPlatform.x + lastPlatform.width < cameraX + WIDTH + 500) {
      const width = randomRange(PLATFORM_MIN_WIDTH, PLATFORM_MAX_WIDTH);

      // Calculate next platform Y with smooth vertical variation & clamping
      let minY = lastPlatform.y - MAX_VERTICAL_DIFF;
      let maxY = lastPlatform.y + MAX_VERTICAL_DIFF;
      if (minY < PLATFORM_MIN_Y) minY = PLATFORM_MIN_Y;
      if (maxY > PLATFORM_MAX_Y) maxY = PLATFORM_MAX_Y;
      let y = randomRange(minY, maxY);

      // Smaller gaps for easier jumps
      const gap = randomRange(60, MAX_PLATFORM_GAP);

      lastPlatform = {
        x: lastPlatform.x + lastPlatform.width + gap,
        y,
        width,
        height: randomRange(PLATFORM_MIN_HEIGHT, PLATFORM_MAX_HEIGHT),
      };
      platforms.push(lastPlatform);
    }
  }

  function rectsIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function update(delta) {
    if (gameOver) return;

    // Horizontal movement
    if (keys.left) {
      player.vx = -PLAYER_SPEED;
    } else if (keys.right) {
      player.vx = PLAYER_SPEED;
    } else {
      player.vx = 0;
    }

    // Jump
    if (keys.jump && player.onPlatform) {
      player.vy = JUMP_VELOCITY;
      player.onPlatform = false;
    }

    // Apply gravity
    player.vy += GRAVITY * delta;
    if (player.vy > MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED;

    // Calculate tentative next position
    let nextX = player.x + player.vx * delta;
    let nextY = player.y + player.vy * delta;

    // Prevent moving beyond left edge of world
    if (nextX < 0) nextX = 0;

    // --- Horizontal collision check ---
    // Move horizontally first, checking collisions
    let horizontalCollision = false;
    for (const p of platforms) {
      if (
        rectsIntersect(nextX, player.y, player.width, player.height, p.x, p.y, p.width, p.height)
      ) {
        // Collision detected, block horizontal movement
        horizontalCollision = true;
        if (player.vx > 0) {
          // Moving right: place player just left of platform
          nextX = p.x - player.width;
        } else if (player.vx < 0) {
          // Moving left: place player just right of platform
          nextX = p.x + p.width;
        }
        player.vx = 0;
      }
    }

    player.x = nextX;

    // --- Vertical collision check ---
    // Apply vertical movement and check if standing on platform
    player.onPlatform = false;
    let verticalCollision = false;

    // We test vertical collisions *after* horizontal position update
    for (const p of platforms) {
      if (
        rectsIntersect(player.x, nextY, player.width, player.height, p.x, p.y, p.width, p.height)
      ) {
        if (player.vy > 0) {
          // Falling and hit platform from above: land on platform
          nextY = p.y - player.height;
          player.vy = 0;
          player.onPlatform = true;
          verticalCollision = true;
        } else if (player.vy < 0) {
          // Hitting platform from below, block upward movement
          nextY = p.y + p.height;
          player.vy = 0;
          verticalCollision = true;
        }
      }
    }

    player.y = nextY;

    // Prevent going above top screen edge
    if (player.y < 0) {
      player.y = 0;
      player.vy = 0;
    }

    // Update camera position to follow player when near right edge
    if (player.x - cameraX > CAMERA_RIGHT_EDGE) {
      cameraX = player.x - CAMERA_RIGHT_EDGE;
    }

    // Prevent camera from going left beyond 0 (world start)
    if (cameraX < 0) cameraX = 0;

    // Remove platforms behind camera by a margin to save memory
    while (platforms.length && platforms[0].x + platforms[0].width < cameraX - 500) {
      platforms.shift();
    }

    // Spawn new platforms ahead
    spawnPlatforms();

    // Check if player falls off bottom of screen
    if (player.y > HEIGHT) {
      gameOver = true;
    }

    // Update score as cameraX (distance scrolled)
    score = cameraX;
    document.getElementById('score').textContent = 'Distance: ' + Math.floor(score);
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Draw platforms relative to camera
    ctx.fillStyle = '#3498db';
    for (const p of platforms) {
      const screenX = p.x - cameraX;
      ctx.fillRect(screenX, p.y, p.width, p.height);
    }

    // Draw player relative to camera
    ctx.fillStyle = '#2ecc71';
    ctx.fillRect(player.x - cameraX, player.y, player.width, player.height);
  }

  function drawGameOver() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    ctx.fillStyle = '#e74c3c';
    ctx.font = 'bold 48px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 20);

    ctx.fillStyle = '#eee';
    ctx.font = '24px monospace';
    ctx.fillText('Distance: ' + Math.floor(score), WIDTH / 2, HEIGHT / 2 + 20);
    ctx.fillText('Press Enter to Restart', WIDTH / 2, HEIGHT / 2 + 60);
  }

  function restart() {
    gameOver = false;
    score = 0;
    cameraX = 0;
    player.x = 50;
    player.y = HEIGHT - 20 - PLAYER_HEIGHT;
    player.vx = 0;
    player.vy = 0;
    player.onPlatform = false;
    platforms = [{
      x: 0,
      y: HEIGHT - 20,
      width: 2000,
      height: 20,
    }];
    lastTime = null;
    document.getElementById('score').textContent = 'Distance: 0';
    requestAnimationFrame(gameLoop);
  }

  function randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  let lastTime = null;

  function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaMs = timestamp - lastTime;
    lastTime = timestamp;

    update(deltaMs / 16.666);
    draw();

    if (gameOver) {
      drawGameOver();
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>

