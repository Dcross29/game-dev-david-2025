<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jumping Platformer</title>
<style>
  body {
    margin: 0;
    background: #222;
    color: #eee;
    font-family: monospace, monospace;
    overflow: hidden;
    user-select: none;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #333;
    border: 2px solid #555;
  }
  #score {
    text-align: center;
    font-size: 20px;
    margin-top: 6px;
  }
</style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>
<div id="score">Score: 0</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Player settings
  const PLAYER_WIDTH = 30;
  const PLAYER_HEIGHT = 50;
  const PLAYER_X = 100; // fixed x position

  const GRAVITY = 0.7;
  const JUMP_VELOCITY = -14;
  const PLATFORM_SPEED = 3;

  let score = 0;
  let gameOver = false;

  // Player state
  const player = {
    x: PLAYER_X,
    y: HEIGHT - PLAYER_HEIGHT,
    width: PLAYER_WIDTH,
    height: PLAYER_HEIGHT,
    vy: 0,
    onPlatform: false,
  };

  // Platforms: array of {x, y, width, height}
  let platforms = [];

  // Initialize with one big platform at bottom
  platforms.push({
    x: 0,
    y: HEIGHT - 20,
    width: WIDTH,
    height: 20,
  });

  // Spawn new platform roughly every ~200 px apart horizontally
  const PLATFORM_MIN_WIDTH = 100;
  const PLATFORM_MAX_WIDTH = 250;
  const PLATFORM_MIN_HEIGHT = 15;
  const PLATFORM_MAX_HEIGHT = 30;
  const PLATFORM_MIN_Y = 150;
  const PLATFORM_MAX_Y = HEIGHT - 50;

  // Input handling
  function jump() {
    if (player.onPlatform && !gameOver) {
      player.vy = JUMP_VELOCITY;
      player.onPlatform = false;
    }
  }

  window.addEventListener('keydown', e => {
    if ((e.code === 'Space' || e.code === 'ArrowUp')) {
      e.preventDefault();
      jump();
    } else if (gameOver && e.code === 'Enter') {
      restart();
    }
  });

  window.addEventListener('mousedown', () => {
    jump();
  });

  // Game loop
  let lastTime = null;
  function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaMs = timestamp - lastTime;
    lastTime = timestamp;

    if (gameOver) {
      drawGameOver();
      return;
    }

    update(deltaMs / 16.666); // normalize delta time to approx 60 FPS
    draw();

    requestAnimationFrame(gameLoop);
  }

  // Update game state
  function update(delta) {
    // Apply gravity
    player.vy += GRAVITY * delta;
    player.y += player.vy * delta;

    // Prevent going above canvas top
    if (player.y < 0) {
      player.y = 0;
      player.vy = 0;
    }

    // Move platforms left
    for (const p of platforms) {
      p.x -= PLATFORM_SPEED * delta;
    }

    // Remove platforms that moved off screen
    while (platforms.length && platforms[0].x + platforms[0].width < 0) {
      platforms.shift();
    }

    // Spawn new platforms to fill screen
    let lastPlatform = platforms[platforms.length - 1];
    while (lastPlatform.x + lastPlatform.width < WIDTH + 200) {
      const width = randomRange(PLATFORM_MIN_WIDTH, PLATFORM_MAX_WIDTH);
      const height = randomRange(PLATFORM_MIN_HEIGHT, PLATFORM_MAX_HEIGHT);
      // Y varies but not too low or too high
      let y = randomRange(PLATFORM_MIN_Y, PLATFORM_MAX_Y);

      // To help gameplay, keep new platform's y close to last one +/- 50 px
      y = clamp(y, Math.max(PLATFORM_MIN_Y, lastPlatform.y - 50), Math.min(PLATFORM_MAX_Y, lastPlatform.y + 50));

      lastPlatform = {
        x: lastPlatform.x + lastPlatform.width + randomRange(100, 200),
        y: y,
        width: width,
        height: height,
      };
      platforms.push(lastPlatform);
    }

    // Collision detection: check if player is standing on a platform
    player.onPlatform = false;
    for (const p of platforms) {
      if (
        player.x + player.width > p.x &&
        player.x < p.x + p.width &&
        player.y + player.height >= p.y &&
        player.y + player.height <= p.y + p.height &&
        player.vy >= 0
      ) {
        // Snap player on top of platform
        player.y = p.y - player.height;
        player.vy = 0;
        player.onPlatform = true;
        break;
      }
    }

    // Check if player falls off screen
    if (player.y > HEIGHT) {
      gameOver = true;
    }

    // Increase score over time
    score += delta * 0.1;
    document.getElementById('score').textContent = 'Score: ' + Math.floor(score);
  }

  // Draw everything
  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Draw player
    ctx.fillStyle = '#2ecc71';
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // Draw platforms
    ctx.fillStyle = '#3498db';
    for (const p of platforms) {
      ctx.fillRect(p.x, p.y, p.width, p.height);
    }
  }

  // Draw game over text
  function drawGameOver() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    ctx.fillStyle = '#e74c3c';
    ctx.font = 'bold 48px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 20);

    ctx.fillStyle = '#eee';
    ctx.font = '24px monospace';
    ctx.fillText('Score: ' + Math.floor(score), WIDTH / 2, HEIGHT / 2 + 20);
    ctx.fillText('Press Enter to Restart', WIDTH / 2, HEIGHT / 2 + 60);
  }

  // Restart game
  function restart() {
    score = 0;
    gameOver = false;
    player.y = HEIGHT - PLAYER_HEIGHT;
    player.vy = 0;
    player.onPlatform = false;
    platforms = [];
    platforms.push({
      x: 0,
      y: HEIGHT - 20,
      width: WIDTH,
      height: 20,
    });
    lastTime = null;
    document.getElementById('score').textContent = 'Score: 0';
    requestAnimationFrame(gameLoop);
  }

  // Helpers
  function randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  function clamp(v, min, max) {
    return Math.min(Math.max(v, min), max);
  }

  // Start game loop
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
